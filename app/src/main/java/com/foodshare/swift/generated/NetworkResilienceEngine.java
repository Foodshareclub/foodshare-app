// Generated by jextract-swift
// Swift module: FoodshareCore

package com.foodshare.swift.generated;

import org.swift.swiftkit.core.*;
import org.swift.swiftkit.core.util.*;
import java.util.*;
import org.swift.swiftkit.core.annotations.*;

/**
 * Network resilience utilities for retry, circuit breaker, and connection health.
 * Uses Swift implementation for cross-platform consistency.
 */
@ThreadSafe
public final class NetworkResilienceEngine {
    static final String LIB_NAME = "FoodshareCore";

    @SuppressWarnings("unused")
    private static final boolean INITIALIZED_LIBS = initializeLibs();

    static boolean initializeLibs() {
        System.loadLibrary(SwiftLibraries.LIB_NAME_SWIFT_JAVA);
        System.loadLibrary(LIB_NAME);
        return true;
    }

    private NetworkResilienceEngine() {
        // Static utility class
    }

    // ==== --------------------------------------------------
    // NetworkResilienceEngine.calculateBackoff

    /**
     * Calculate backoff delay for a retry attempt.
     *
     * @param attempt Current attempt number (0-indexed)
     * @param baseDelayMs Base delay in milliseconds
     * @param maxDelayMs Maximum delay in milliseconds
     * @param strategy Backoff strategy: "constant", "linear", "exponential", "exponentialWithJitter", "fullJitter", "equalJitter"
     * @return Delay in milliseconds
     */
    public static int calculateBackoff(int attempt, int baseDelayMs, int maxDelayMs, String strategy) {
        return $calculateBackoff(attempt, baseDelayMs, maxDelayMs, strategy);
    }

    private static native int $calculateBackoff(int attempt, int baseDelayMs, int maxDelayMs, String strategy);

    // ==== --------------------------------------------------
    // NetworkResilienceEngine.shouldRetry

    /**
     * Determine if a request should be retried based on HTTP status code.
     *
     * @param statusCode HTTP status code
     * @param currentAttempt Current attempt number (0-indexed)
     * @param maxAttempts Maximum attempts allowed
     * @return RetryDecision with delay and reason
     */
    public static RetryDecision shouldRetry(int statusCode, int currentAttempt, int maxAttempts) {
        long ptr = $shouldRetry(statusCode, currentAttempt, maxAttempts);
        return new RetryDecision(ptr);
    }

    private static native long $shouldRetry(int statusCode, int currentAttempt, int maxAttempts);

    // ==== --------------------------------------------------
    // NetworkResilienceEngine.evaluateCircuitState

    /**
     * Evaluate circuit breaker state to decide if request should proceed.
     *
     * @param stateJson Optional current state as JSON string
     * @return CircuitBreakerDecision with allowed status and state
     */
    public static CircuitBreakerDecision evaluateCircuitState(String stateJson) {
        long ptr = $evaluateCircuitState(stateJson);
        return new CircuitBreakerDecision(ptr);
    }

    private static native long $evaluateCircuitState(String stateJson);

    // ==== --------------------------------------------------
    // NetworkResilienceEngine.getCircuitBreakerConfig

    /**
     * Get circuit breaker configuration for a preset.
     *
     * @param preset "default", "sensitive", or "tolerant"
     * @return CircuitBreakerConfig
     */
    public static CircuitBreakerConfig getCircuitBreakerConfig(String preset) {
        long ptr = $getCircuitBreakerConfig(preset);
        return new CircuitBreakerConfig(ptr);
    }

    private static native long $getCircuitBreakerConfig(String preset);

    // ==== --------------------------------------------------
    // NetworkResilienceEngine.evaluateConnectionHealth

    /**
     * Evaluate connection health from metrics.
     *
     * @param errorRate Error rate (0.0 - 1.0)
     * @param averageLatencyMs Average latency in milliseconds (null if unknown)
     * @param connectionType Type of connection: "wifi", "cellular", "ethernet", "unknown", "none"
     * @return ConnectionHealthResult with status and recommendations
     */
    public static ConnectionHealthResult evaluateConnectionHealth(double errorRate, Double averageLatencyMs, String connectionType) {
        boolean hasLatency = averageLatencyMs != null;
        double latency = hasLatency ? averageLatencyMs : 0.0;
        long ptr = $evaluateConnectionHealth(errorRate, latency, hasLatency, connectionType);
        return new ConnectionHealthResult(ptr);
    }

    private static native long $evaluateConnectionHealth(double errorRate, double averageLatencyMs, boolean hasLatency, String connectionType);

    // ==== --------------------------------------------------
    // NetworkResilienceEngine.getRetryConfig

    /**
     * Get retry policy configuration for a preset.
     *
     * @param preset "default", "aggressive", "conservative", "noRetry", "rateLimitAware"
     * @return RetryConfig
     */
    public static RetryConfig getRetryConfig(String preset) {
        long ptr = $getRetryConfig(preset);
        return new RetryConfig(ptr);
    }

    private static native long $getRetryConfig(String preset);
}
