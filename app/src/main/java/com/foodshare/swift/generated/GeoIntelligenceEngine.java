// Generated by jextract-swift
package com.foodshare.swift.generated;

import org.swift.swiftkit.core.annotations.*;

/**
 * Swift GeoIntelligenceEngine for spatial algorithms.
 * Thread-safe static methods delegating to Swift implementation.
 */
@ThreadSafe
public final class GeoIntelligenceEngine {
    private GeoIntelligenceEngine() {}

    static {
        System.loadLibrary("FoodshareCore");
    }

    // Distance Calculation
    public static double calculateDistance(double fromLat, double fromLng, double toLat, double toLng) {
        return $calculateDistance(fromLat, fromLng, toLat, toLng);
    }

    // Bounding Box
    public static GeoBoundingBox calculateBoundingBox(double centerLat, double centerLng, double radiusKm) {
        long ptr = $calculateBoundingBox(centerLat, centerLng, radiusKm);
        return new GeoBoundingBox(ptr);
    }

    // Route Optimization
    public static OptimizedRoute optimizeRoute(
            double startLat, double startLng,
            String waypointLatsCsv, String waypointLngsCsv,
            boolean returnToStart) {
        long ptr = $optimizeRoute(startLat, startLng, waypointLatsCsv, waypointLngsCsv, returnToStart);
        return new OptimizedRoute(ptr);
    }

    // Geofencing
    public static SwiftGeofenceResult checkGeofence(
            double locationLat, double locationLng,
            double centerLat, double centerLng, double radiusKm) {
        long ptr = $checkGeofence(locationLat, locationLng, centerLat, centerLng, radiusKm);
        return new SwiftGeofenceResult(ptr);
    }

    // Geohash
    public static String encodeGeohash(double lat, double lng, int precision) {
        return $encodeGeohash(lat, lng, precision);
    }

    public static GeoBoundingBox decodeGeohash(String hash) {
        long ptr = $decodeGeohash(hash);
        return new GeoBoundingBox(ptr);
    }

    // Travel Time
    public static TravelTimeEstimate estimateTravelTime(
            double fromLat, double fromLng, double toLat, double toLng, int mode) {
        long ptr = $estimateTravelTime(fromLat, fromLng, toLat, toLng, mode);
        return new TravelTimeEstimate(ptr);
    }

    // Location Privacy
    public static SwiftCoordinate obfuscateLocation(double lat, double lng, int precision) {
        long ptr = $obfuscateLocation(lat, lng, precision);
        return new SwiftCoordinate(ptr);
    }

    // Grid Cell
    public static String getGridCellKey(double lat, double lng, double gridSizeKm) {
        return $getGridCellKey(lat, lng, gridSizeKm);
    }

    // Native methods
    private static native double $calculateDistance(double fromLat, double fromLng, double toLat, double toLng);
    private static native long $calculateBoundingBox(double centerLat, double centerLng, double radiusKm);
    private static native long $optimizeRoute(double startLat, double startLng, String waypointLatsCsv, String waypointLngsCsv, boolean returnToStart);
    private static native long $checkGeofence(double locationLat, double locationLng, double centerLat, double centerLng, double radiusKm);
    private static native String $encodeGeohash(double lat, double lng, int precision);
    private static native long $decodeGeohash(String hash);
    private static native long $estimateTravelTime(double fromLat, double fromLng, double toLat, double toLng, int mode);
    private static native long $obfuscateLocation(double lat, double lng, int precision);
    private static native String $getGridCellKey(double lat, double lng, double gridSizeKm);
}
