// Generated by jextract-swift
// Swift module: FoodshareCore

package com.foodshare.swift.generated;

import org.swift.swiftkit.core.*;
import org.swift.swiftkit.core.util.*;
import org.swift.swiftkit.core.annotations.*;

/**
 * Recommendation engine for personalized feeds.
 * Uses Swift implementation for cross-platform consistency.
 */
@ThreadSafe
public final class RecommendationEngine {
    static final String LIB_NAME = "FoodshareCore";

    @SuppressWarnings("unused")
    private static final boolean INITIALIZED_LIBS = initializeLibs();

    static boolean initializeLibs() {
        System.loadLibrary(SwiftLibraries.LIB_NAME_SWIFT_JAVA);
        System.loadLibrary(LIB_NAME);
        return true;
    }

    private RecommendationEngine() {
        // Static utility class
    }

    // ==== --------------------------------------------------
    // RecommendationEngine.getRankingWeights

    /**
     * Get ranking weights for a preset.
     *
     * @param preset "default", "forYou", "nearby", "popular", "expiringSoon"
     * @return RankingWeights configuration
     */
    public static RankingWeights getRankingWeights(String preset) {
        long ptr = $getRankingWeights(preset);
        return new RankingWeights(ptr);
    }

    private static native long $getRankingWeights(String preset);

    // ==== --------------------------------------------------
    // RecommendationEngine.computeDecayScore

    /**
     * Compute decay score for content age.
     *
     * @param ageSeconds Age of content in seconds
     * @param strategy Decay strategy: "exponential", "linear", "inverse", "step", "foodFreshness"
     * @param parameter Strategy parameter
     * @return DecayResult with score and description
     */
    public static SwiftDecayResult computeDecayScore(double ageSeconds, String strategy, double parameter) {
        long ptr = $computeDecayScore(ageSeconds, strategy, parameter);
        return new SwiftDecayResult(ptr);
    }

    private static native long $computeDecayScore(double ageSeconds, String strategy, double parameter);

    // ==== --------------------------------------------------
    // RecommendationEngine.calculateRelevance

    /**
     * Calculate relevance score for a content item.
     *
     * @return SwiftRelevanceResult with score and component breakdown
     */
    public static SwiftRelevanceResult calculateRelevance(
            double categoryAffinity,
            Double distanceKm,
            Double maxDistanceKm,
            double ageSeconds,
            int viewCount,
            int favoriteCount,
            int claimCount,
            Double donorRating,
            boolean donorIsVerified,
            boolean preferVerifiedDonors,
            Double minDonorRating,
            double dietaryMatchRatio,
            boolean isExcludedCategory,
            String preset
    ) {
        boolean hasDistance = distanceKm != null;
        boolean hasMaxDistance = maxDistanceKm != null;
        boolean hasDonorRating = donorRating != null;
        boolean hasMinDonorRating = minDonorRating != null;

        long ptr = $calculateRelevance(
                categoryAffinity,
                hasDistance ? distanceKm : 0.0,
                hasDistance,
                hasMaxDistance ? maxDistanceKm : 0.0,
                hasMaxDistance,
                ageSeconds,
                viewCount,
                favoriteCount,
                claimCount,
                hasDonorRating ? donorRating : 0.0,
                hasDonorRating,
                donorIsVerified,
                preferVerifiedDonors,
                hasMinDonorRating ? minDonorRating : 0.0,
                hasMinDonorRating,
                dietaryMatchRatio,
                isExcludedCategory,
                preset
        );
        return new SwiftRelevanceResult(ptr);
    }

    private static native long $calculateRelevance(
            double categoryAffinity,
            double distanceKm,
            boolean hasDistance,
            double maxDistanceKm,
            boolean hasMaxDistance,
            double ageSeconds,
            int viewCount,
            int favoriteCount,
            int claimCount,
            double donorRating,
            boolean hasDonorRating,
            boolean donorIsVerified,
            boolean preferVerifiedDonors,
            double minDonorRating,
            boolean hasMinDonorRating,
            double dietaryMatchRatio,
            boolean isExcludedCategory,
            String preset
    );

    // ==== --------------------------------------------------
    // RecommendationEngine.updateAffinity

    /**
     * Update category affinity based on user action.
     *
     * @param eventType "view", "favorite", "claim", "engagement", "like", "dislike", "neutral"
     * @param eventValue Optional value (e.g., engagement seconds)
     * @return Updated affinity values
     */
    public static AffinityUpdateResult updateAffinity(
            int viewCount,
            int favoriteCount,
            int claimCount,
            double engagementSeconds,
            int explicitPreference,
            String eventType,
            double eventValue
    ) {
        long ptr = $updateAffinity(viewCount, favoriteCount, claimCount, engagementSeconds, explicitPreference, eventType, eventValue);
        return new AffinityUpdateResult(ptr);
    }

    private static native long $updateAffinity(
            int viewCount,
            int favoriteCount,
            int claimCount,
            double engagementSeconds,
            int explicitPreference,
            String eventType,
            double eventValue
    );

    // ==== --------------------------------------------------
    // RecommendationEngine.calculateFreshness

    /**
     * Calculate freshness score for a listing.
     *
     * @param ageSeconds Age of listing in seconds
     * @param expiresInSeconds Seconds until expiration (null if no expiration)
     * @return Freshness score (0.0-1.0)
     */
    public static double calculateFreshness(double ageSeconds, Double expiresInSeconds) {
        boolean hasExpiration = expiresInSeconds != null;
        return $calculateFreshness(ageSeconds, hasExpiration ? expiresInSeconds : 0.0, hasExpiration);
    }

    private static native double $calculateFreshness(double ageSeconds, double expiresInSeconds, boolean hasExpiration);
}
